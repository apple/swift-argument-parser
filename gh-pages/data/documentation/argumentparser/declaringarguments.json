{
  "abstract" : [
    {
      "text" : "Use the ",
      "type" : "text"
    },
    {
      "code" : "@Argument",
      "type" : "codeVoice"
    },
    {
      "text" : ", ",
      "type" : "text"
    },
    {
      "code" : "@Option",
      "type" : "codeVoice"
    },
    {
      "text" : " and ",
      "type" : "text"
    },
    {
      "code" : "@Flag",
      "type" : "codeVoice"
    },
    {
      "text" : " property wrappers to declare the command-line interface for your command.",
      "type" : "text"
    }
  ],
  "hierarchy" : {
    "paths" : [
      [
        "doc:\/\/ArgumentParser\/documentation\/ArgumentParser"
      ]
    ]
  },
  "identifier" : {
    "interfaceLanguage" : "swift",
    "url" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/DeclaringArguments"
  },
  "kind" : "article",
  "metadata" : {
    "modules" : [
      {
        "name" : "ArgumentParser"
      }
    ],
    "role" : "article",
    "roleHeading" : "Article",
    "title" : "Declaring Arguments, Options, and Flags"
  },
  "primaryContentSections" : [
    {
      "content" : [
        {
          "anchor" : "Overview",
          "level" : 2,
          "text" : "Overview",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "When creating commands, you can define three primary kinds of command-line inputs:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "items" : [
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "inlineContent" : [
                        {
                          "text" : "Arguments",
                          "type" : "text"
                        }
                      ],
                      "type" : "emphasis"
                    },
                    {
                      "text" : " are values given by a user and are read in order from first to last (see ",
                      "type" : "text"
                    },
                    {
                      "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Argument",
                      "isActive" : true,
                      "type" : "reference"
                    },
                    {
                      "text" : "). For example, this command is called with three file names as arguments:",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                },
                {
                  "code" : [
                    "% example file1.swift file2.swift file3.swift"
                  ],
                  "syntax" : null,
                  "type" : "codeListing"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "inlineContent" : [
                        {
                          "text" : "Options",
                          "type" : "text"
                        }
                      ],
                      "type" : "emphasis"
                    },
                    {
                      "text" : " are named key-value pairs. Keys start with one or two dashes (",
                      "type" : "text"
                    },
                    {
                      "code" : "-",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " or ",
                      "type" : "text"
                    },
                    {
                      "code" : "--",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : "), and a user can separate the key and value with an equal sign (",
                      "type" : "text"
                    },
                    {
                      "code" : "=",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : ") or a space (see ",
                      "type" : "text"
                    },
                    {
                      "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Option",
                      "isActive" : true,
                      "type" : "reference"
                    },
                    {
                      "text" : "). This command is called with two options:",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                },
                {
                  "code" : [
                    "% example --count=5 --index 2"
                  ],
                  "syntax" : null,
                  "type" : "codeListing"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "inlineContent" : [
                        {
                          "text" : "Flags",
                          "type" : "text"
                        }
                      ],
                      "type" : "emphasis"
                    },
                    {
                      "text" : " are like options, but without a paired value. Instead, their presence indicates a particular value (see ",
                      "type" : "text"
                    },
                    {
                      "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Flag",
                      "isActive" : true,
                      "type" : "reference"
                    },
                    {
                      "text" : "). This command is called with two flags:",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                },
                {
                  "code" : [
                    "% example --verbose --strip-whitespace"
                  ],
                  "syntax" : null,
                  "type" : "codeListing"
                }
              ]
            }
          ],
          "type" : "unorderedList"
        },
        {
          "inlineContent" : [
            {
              "text" : "The three preceding examples could be calls of this ",
              "type" : "text"
            },
            {
              "code" : "Example",
              "type" : "codeVoice"
            },
            {
              "text" : " command:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Example: ParsableCommand {",
            "    @Argument var files: [String] = []",
            "    @Option var count: Int?",
            "    @Option var index = 0",
            "    @Flag var verbose = false",
            "    @Flag var stripWhitespace = false",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "This example shows how ",
              "type" : "text"
            },
            {
              "code" : "ArgumentParser",
              "type" : "codeVoice"
            },
            {
              "text" : " provides defaults that speed up your initial development process:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "items" : [
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Option and flag names are derived from the names of your command’s properties.",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "What kinds of inputs are valid, and whether arguments are required, is based on your properties’ types and default values.",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            }
          ],
          "type" : "unorderedList"
        },
        {
          "inlineContent" : [
            {
              "text" : "In this example, all of the properties have default values (optional properties default to ",
              "type" : "text"
            },
            {
              "code" : "nil",
              "type" : "codeVoice"
            },
            {
              "text" : ").",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "Users must provide values for all properties with no implicit or specified default. For example, this command would require one integer argument and a string with the key ",
              "type" : "text"
            },
            {
              "code" : "--user-name",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Example: ParsableCommand {",
            "    @Option var userName: String",
            "    @Argument var value: Int",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "When called without both values, the command exits with an error:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example 5",
            "Error: Missing '--user-name <user-name>'",
            "Usage: example --user-name <user-name> <value>",
            "  See 'example --help' for more information.",
            "% example --user-name kjohnson",
            "Error: Missing '<value>'",
            "Usage: example --user-name <user-name> <value>",
            "  See 'example --help' for more information."
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "When providing a default value for an array property, any user-supplied values replace the entire default.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Lucky: ParsableCommand {",
            "    @Argument var numbers = [7, 14, 21]",
            "",
            "    mutating func run() throws {",
            "        print(\"\"\"",
            "        Your lucky numbers are:",
            "        \\(numbers.map(String.init).joined(separator: \" \"))",
            "        \"\"\")",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "code" : [
            "% lucky ",
            "Your lucky numbers are:",
            "7 14 21",
            "% lucky 1 2 3",
            "Your lucky numbers are:",
            "1 2 3"
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "anchor" : "Customizing-option-and-flag-names",
          "level" : 2,
          "text" : "Customizing option and flag names",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "By default, options and flags derive the name that you use on the command line from the name of the property, such as ",
              "type" : "text"
            },
            {
              "code" : "--count",
              "type" : "codeVoice"
            },
            {
              "text" : " and ",
              "type" : "text"
            },
            {
              "code" : "--index",
              "type" : "codeVoice"
            },
            {
              "text" : ". Camel-case names are converted to lowercase with hyphen-separated words, like ",
              "type" : "text"
            },
            {
              "code" : "--strip-whitespace",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can override this default by specifying one or more name specifications in the ",
              "type" : "text"
            },
            {
              "code" : "@Option",
              "type" : "codeVoice"
            },
            {
              "text" : " or ",
              "type" : "text"
            },
            {
              "code" : "@Flag",
              "type" : "codeVoice"
            },
            {
              "text" : " initializers. This command demonstrates the four name specifications:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Example: ParsableCommand {",
            "    @Flag(name: .long)  \/\/ Same as the default",
            "    var stripWhitespace = false",
            "",
            "    @Flag(name: .short)",
            "    var verbose = false",
            "",
            "    @Option(name: .customLong(\"count\"))",
            "    var iterationCount: Int",
            "",
            "    @Option(name: [.customShort(\"I\"), .long])",
            "    var inputFile: String",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "items" : [
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Specifying ",
                      "type" : "text"
                    },
                    {
                      "code" : ".long",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " or ",
                      "type" : "text"
                    },
                    {
                      "code" : ".short",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " uses the property’s name as the source of the command-line name. Long names use the whole name, prefixed by two dashes, while short names are a single character prefixed by a single dash. In this example, the ",
                      "type" : "text"
                    },
                    {
                      "code" : "stripWhitespace",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " and ",
                      "type" : "text"
                    },
                    {
                      "code" : "verbose",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " flags are specified in this way:",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                },
                {
                  "code" : [
                    "% example --strip-whitespace -v"
                  ],
                  "syntax" : null,
                  "type" : "codeListing"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Specifying ",
                      "type" : "text"
                    },
                    {
                      "code" : ".customLong(_:)",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " or ",
                      "type" : "text"
                    },
                    {
                      "code" : ".customShort(_:)",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " uses the given string or character as the long or short name for the property.",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                },
                {
                  "code" : [
                    "% example --count 10 -I file1.swift"
                  ],
                  "syntax" : null,
                  "type" : "codeListing"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "text" : "Use array literal syntax to specify multiple names. The ",
                      "type" : "text"
                    },
                    {
                      "code" : "inputFile",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " property can alternatively be given with the default long name:",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                },
                {
                  "code" : [
                    "% example --input-file file1.swift"
                  ],
                  "syntax" : null,
                  "type" : "codeListing"
                }
              ]
            }
          ],
          "type" : "unorderedList"
        },
        {
          "inlineContent" : [
            {
              "inlineContent" : [
                {
                  "text" : "Note:",
                  "type" : "text"
                }
              ],
              "type" : "strong"
            },
            {
              "text" : " You can also pass ",
              "type" : "text"
            },
            {
              "code" : "withSingleDash: true",
              "type" : "codeVoice"
            },
            {
              "text" : " to ",
              "type" : "text"
            },
            {
              "code" : ".customLong",
              "type" : "codeVoice"
            },
            {
              "text" : " to create a single-dash flag or option, such as ",
              "type" : "text"
            },
            {
              "code" : "-verbose",
              "type" : "codeVoice"
            },
            {
              "text" : ". Use this name specification only when necessary, such as when migrating a legacy command-line interface. Using long names with a single-dash prefix can lead to ambiguity with combined short names: it may not be obvious whether ",
              "type" : "text"
            },
            {
              "code" : "-file",
              "type" : "codeVoice"
            },
            {
              "text" : " is a single option or the combination of the four short options ",
              "type" : "text"
            },
            {
              "code" : "-f",
              "type" : "codeVoice"
            },
            {
              "text" : ", ",
              "type" : "text"
            },
            {
              "code" : "-i",
              "type" : "codeVoice"
            },
            {
              "text" : ", ",
              "type" : "text"
            },
            {
              "code" : "-l",
              "type" : "codeVoice"
            },
            {
              "text" : ", and ",
              "type" : "text"
            },
            {
              "code" : "-e",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Parsing-custom-types",
          "level" : 2,
          "text" : "Parsing custom types",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Arguments and options can be parsed from any type that conforms to the ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : " protocol. Standard library integer and floating-point types, strings, and Booleans all conform to ",
              "type" : "text"
            },
            {
              "code" : "ExpressibleByArgument",
              "type" : "codeVoice"
            },
            {
              "text" : ".",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can make your own custom types conform to ",
              "type" : "text"
            },
            {
              "code" : "ExpressibleByArgument",
              "type" : "codeVoice"
            },
            {
              "text" : " by implementing ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument\/init(argument:)",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : ":",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Path: ExpressibleByArgument {",
            "    var pathString: String",
            "",
            "    init?(argument: String) {",
            "        self.pathString = argument",
            "    }",
            "}",
            "",
            "struct Example: ParsableCommand {",
            "    @Argument var inputFile: Path",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The library provides a default implementation for ",
              "type" : "text"
            },
            {
              "code" : "RawRepresentable",
              "type" : "codeVoice"
            },
            {
              "text" : " types, like string-backed enumerations, so you only need to declare conformance.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "enum ReleaseMode: String, ExpressibleByArgument {",
            "    case debug, release",
            "}",
            "",
            "struct Example: ParsableCommand {",
            "    @Option var mode: ReleaseMode",
            "",
            "    mutating func run() throws {",
            "        print(mode)",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The user can provide the raw values on the command line, which are then converted to your custom type. Only valid values are allowed:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --mode release",
            "release",
            "% example --mode future",
            "Error: The value 'future' is invalid for '--mode <mode>'"
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "To use a non-",
              "type" : "text"
            },
            {
              "code" : "ExpressibleByArgument",
              "type" : "codeVoice"
            },
            {
              "text" : " type for an argument or option, you can instead provide a throwing ",
              "type" : "text"
            },
            {
              "code" : "transform",
              "type" : "codeVoice"
            },
            {
              "text" : " function that converts the parsed string to your desired type. This is a good idea for custom types that are more complex than a ",
              "type" : "text"
            },
            {
              "code" : "RawRepresentable",
              "type" : "codeVoice"
            },
            {
              "text" : " type, or for types you don’t define yourself.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "enum Format {",
            "    case text",
            "    case other(String)",
            "",
            "    init(_ string: String) throws {",
            "        if string == \"text\" {",
            "            self = .text",
            "        } else {",
            "            self = .other(string)",
            "        }",
            "    }",
            "}",
            "",
            "struct Example: ParsableCommand {",
            "    @Argument(transform: Format.init)",
            "    var format: Format",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Throw an error from the ",
              "type" : "text"
            },
            {
              "code" : "transform",
              "type" : "codeVoice"
            },
            {
              "text" : " function to indicate that the user provided an invalid value for that type. See ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Validation",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : " for more about customizing ",
              "type" : "text"
            },
            {
              "code" : "transform",
              "type" : "codeVoice"
            },
            {
              "text" : " function errors.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Using-flag-inversions,-enumerations,-and-counts",
          "level" : 2,
          "text" : "Using flag inversions, enumerations, and counts",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "Flags are most frequently used for ",
              "type" : "text"
            },
            {
              "code" : "Bool",
              "type" : "codeVoice"
            },
            {
              "text" : " properties. You can generate a ",
              "type" : "text"
            },
            {
              "code" : "true",
              "type" : "codeVoice"
            },
            {
              "text" : "\/",
              "type" : "text"
            },
            {
              "code" : "false",
              "type" : "codeVoice"
            },
            {
              "text" : " pair of flags by specifying a flag inversion:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Example: ParsableCommand {",
            "    @Flag(inversion: .prefixedNo)",
            "    var index = true",
            "",
            "    @Flag(inversion: .prefixedEnableDisable)",
            "    var requiredElement: Bool",
            "",
            "    mutating func run() throws {",
            "        print(index, requiredElement)",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "When declaring a flag with an inversion, set the default by specifying ",
              "type" : "text"
            },
            {
              "code" : "true",
              "type" : "codeVoice"
            },
            {
              "text" : " or ",
              "type" : "text"
            },
            {
              "code" : "false",
              "type" : "codeVoice"
            },
            {
              "text" : " as the property’s initial value. If you want to require that the user specify one of the two inversions, leave off the default value.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "In the ",
              "type" : "text"
            },
            {
              "code" : "Example",
              "type" : "codeVoice"
            },
            {
              "text" : " command defined above, a flag is required for the ",
              "type" : "text"
            },
            {
              "code" : "requiredElement",
              "type" : "codeVoice"
            },
            {
              "text" : " property. The specified prefixes are prepended to the long names for the flags:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --enable-required-element",
            "true true",
            "% example --no-index --disable-required-element",
            "false false",
            "% example --index",
            "Error: Missing one of: '--enable-required-element', '--disable-required-element'"
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "To create a flag with custom names for a Boolean value, to provide an exclusive choice between more than two names, or for collecting multiple values from a set of defined choices, define an enumeration that conforms to the ",
              "type" : "text"
            },
            {
              "code" : "EnumerableFlag",
              "type" : "codeVoice"
            },
            {
              "text" : " protocol.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "enum CacheMethod: String, EnumerableFlag {",
            "    case inMemoryCache",
            "    case persistentCache",
            "}",
            "",
            "enum Color: String, EnumerableFlag {",
            "    case pink, purple, silver",
            "}",
            "",
            "struct Example: ParsableCommand {",
            "    @Flag var cacheMethod: CacheMethod",
            "    @Flag var colors: [Color] = []",
            "",
            "    mutating func run() throws {",
            "        print(cacheMethod)",
            "        print(colors)",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The flag names in this case are drawn from the raw values — for information about customizing the names and help text, see the  ",
              "type" : "text"
            },
            {
              "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/EnumerableFlag",
              "isActive" : true,
              "type" : "reference"
            },
            {
              "text" : " documentation.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --in-memory-cache --pink --silver",
            ".inMemoryCache",
            "[.pink, .silver]",
            "% example",
            "Error: Missing one of: '--in-memory-cache', '--persistent-cache'"
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Finally, when a flag is of type ",
              "type" : "text"
            },
            {
              "code" : "Int",
              "type" : "codeVoice"
            },
            {
              "text" : ", the value is parsed as a count of the number of times that the flag is specified.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Example: ParsableCommand {",
            "    @Flag(name: .shortAndLong)",
            "    var verbose: Int",
            "",
            "    mutating func run() throws {",
            "        print(\"Verbosity level: \\(verbose)\")",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "In this example, ",
              "type" : "text"
            },
            {
              "code" : "verbose",
              "type" : "codeVoice"
            },
            {
              "text" : " defaults to zero, and counts the number of times that ",
              "type" : "text"
            },
            {
              "code" : "-v",
              "type" : "codeVoice"
            },
            {
              "text" : " or ",
              "type" : "text"
            },
            {
              "code" : "--verbose",
              "type" : "codeVoice"
            },
            {
              "text" : " is given.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --verbose",
            "Verbosity level: 1",
            "% example -vvvv",
            "Verbosity level: 4"
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "anchor" : "Specifying-default-values",
          "level" : 2,
          "text" : "Specifying default values",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can specify default values for almost all supported argument, option, and flag types using normal property initialization syntax:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "enum CustomFlag: String, EnumerableFlag {",
            "    case foo, bar, baz",
            "}",
            "",
            "struct Example: ParsableCommand {",
            "    @Flag",
            "    var booleanFlag = false",
            "",
            "    @Flag",
            "    var arrayFlag: [CustomFlag] = [.foo, .baz]",
            "",
            "    @Option",
            "    var singleOption = 0",
            "",
            "    @Option",
            "    var arrayOption = [\"bar\", \"qux\"]",
            "",
            "    @Argument",
            "    var singleArgument = \"quux\"",
            "",
            "    @Argument",
            "    var arrayArgument = [\"quux\", \"quuz\"]",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "This includes all of the variants of the argument types above (including ",
              "type" : "text"
            },
            {
              "code" : "@Option(transform: ...)",
              "type" : "codeVoice"
            },
            {
              "text" : ", etc.), with a few notable exceptions:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "items" : [
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "code" : "Optional",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : "-typed values (which default to ",
                      "type" : "text"
                    },
                    {
                      "code" : "nil",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " and for which a default would not make sense, as the value could never be ",
                      "type" : "text"
                    },
                    {
                      "code" : "nil",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : ")",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            },
            {
              "content" : [
                {
                  "inlineContent" : [
                    {
                      "code" : "Int",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : " flags (which are used for counting the number of times a flag is specified and therefore default to ",
                      "type" : "text"
                    },
                    {
                      "code" : "0",
                      "type" : "codeVoice"
                    },
                    {
                      "text" : ")",
                      "type" : "text"
                    }
                  ],
                  "type" : "paragraph"
                }
              ]
            }
          ],
          "type" : "unorderedList"
        },
        {
          "inlineContent" : [
            {
              "text" : "If a default is not specified, the user must provide a value for that argument\/option\/flag or will receive an error that the value is missing.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "You must also always specify a default of ",
              "type" : "text"
            },
            {
              "code" : "false",
              "type" : "codeVoice"
            },
            {
              "text" : " for a non-optional ",
              "type" : "text"
            },
            {
              "code" : "Bool",
              "type" : "codeVoice"
            },
            {
              "text" : " flag, as in the example above. This makes the behavior consistent with both normal Swift properties (which either must be explicitly initialized or optional to initialize a ",
              "type" : "text"
            },
            {
              "code" : "struct",
              "type" : "codeVoice"
            },
            {
              "text" : "\/",
              "type" : "text"
            },
            {
              "code" : "class",
              "type" : "codeVoice"
            },
            {
              "text" : " containing them) and the other property types.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Specifying-a-parsing-strategy",
          "level" : 2,
          "text" : "Specifying a parsing strategy",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "When parsing a list of command-line inputs, ",
              "type" : "text"
            },
            {
              "code" : "ArgumentParser",
              "type" : "codeVoice"
            },
            {
              "text" : " distinguishes between dash-prefixed keys and un-prefixed values. When looking for the value for a key, only an un-prefixed value will be selected by default.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "For example, this command defines a ",
              "type" : "text"
            },
            {
              "code" : "--verbose",
              "type" : "codeVoice"
            },
            {
              "text" : " flag, a ",
              "type" : "text"
            },
            {
              "code" : "--name",
              "type" : "codeVoice"
            },
            {
              "text" : " option, and an optional ",
              "type" : "text"
            },
            {
              "code" : "file",
              "type" : "codeVoice"
            },
            {
              "text" : " argument:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Example: ParsableCommand {",
            "    @Flag var verbose = false",
            "    @Option var name: String",
            "    @Argument var file: String?",
            "",
            "    mutating func run() throws {",
            "        print(\"Verbose: \\(verbose), name: \\(name), file: \\(file ?? \"none\")\")",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "When calling this command, the value for ",
              "type" : "text"
            },
            {
              "code" : "--name",
              "type" : "codeVoice"
            },
            {
              "text" : " must be given immediately after the key. If the ",
              "type" : "text"
            },
            {
              "code" : "--verbose",
              "type" : "codeVoice"
            },
            {
              "text" : " flag is placed in between, parsing fails with an error:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --verbose --name Tomás",
            "Verbose: true, name: Tomás, file: none",
            "% example --name --verbose Tomás",
            "Error: Missing value for '--name <name>'",
            "Usage: example [--verbose] --name <name> [<file>]",
            "  See 'example --help' for more information."
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Parsing options as arrays is similar — only adjacent key-value pairs are recognized by default.",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "anchor" : "Alternative-single-value-parsing-strategies",
          "level" : 3,
          "text" : "Alternative single-value parsing strategies",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "You can change this behavior by providing a different parsing strategy in the ",
              "type" : "text"
            },
            {
              "code" : "@Option",
              "type" : "codeVoice"
            },
            {
              "text" : " initializer. ",
              "type" : "text"
            },
            {
              "inlineContent" : [
                {
                  "text" : "Be careful when selecting any of the alternative parsing strategies",
                  "type" : "text"
                }
              ],
              "type" : "strong"
            },
            {
              "text" : " — they may lead your command-line tool to have unexpected behavior for users!",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : ".unconditional",
              "type" : "codeVoice"
            },
            {
              "text" : " parsing strategy uses the immediate next input for the value of the option, even if it starts with a dash. If ",
              "type" : "text"
            },
            {
              "code" : "name",
              "type" : "codeVoice"
            },
            {
              "text" : " were instead defined as ",
              "type" : "text"
            },
            {
              "code" : "@Option(parsing: .unconditional) var name: String",
              "type" : "codeVoice"
            },
            {
              "text" : ", the second attempt would result in ",
              "type" : "text"
            },
            {
              "code" : "\"--verbose\"",
              "type" : "codeVoice"
            },
            {
              "text" : " being read as the value of ",
              "type" : "text"
            },
            {
              "code" : "name",
              "type" : "codeVoice"
            },
            {
              "text" : ":",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --name --verbose Tomás",
            "Verbose: false, name: --verbose, file: Tomás"
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : ".scanningForValue",
              "type" : "codeVoice"
            },
            {
              "text" : " strategy, on the other hand, looks ahead in the list of command-line inputs and uses the first un-prefixed value as the input, even if that requires skipping over other flags or options.  If ",
              "type" : "text"
            },
            {
              "code" : "name",
              "type" : "codeVoice"
            },
            {
              "text" : " were defined as ",
              "type" : "text"
            },
            {
              "code" : "@Option(parsing: .scanningForValue) var name: String",
              "type" : "codeVoice"
            },
            {
              "text" : ", the parser would look ahead to find ",
              "type" : "text"
            },
            {
              "code" : "Tomás",
              "type" : "codeVoice"
            },
            {
              "text" : ", then pick up parsing where it left off to get the ",
              "type" : "text"
            },
            {
              "code" : "--verbose",
              "type" : "codeVoice"
            },
            {
              "text" : " flag:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --name --verbose Tomás",
            "Verbose: true, name: Tomás, file: none"
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "anchor" : "Alternative-array-parsing-strategies",
          "level" : 3,
          "text" : "Alternative array parsing strategies",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "The default strategy for parsing options as arrays is to read each value from a key-value pair. For example, this command expects zero or more input file names:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Example: ParsableCommand {",
            "    @Option var file: [String] = []",
            "    @Flag var verbose = false",
            "",
            "    mutating func run() throws {",
            "        print(\"Verbose: \\(verbose), files: \\(file)\")",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "As with single values, each time the user provides the ",
              "type" : "text"
            },
            {
              "code" : "--file",
              "type" : "codeVoice"
            },
            {
              "text" : " key, they must also provide a value:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --verbose --file file1.swift --file file2.swift",
            "Verbose: true, files: [\"file1.swift\", \"file2.swift\"]",
            "% example --file --verbose file1.swift --file file2.swift",
            "Error: Missing value for '--file <file>'",
            "Usage: example [--file <file> ...] [--verbose]",
            "  See 'example --help' for more information."
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : ".unconditionalSingleValue",
              "type" : "codeVoice"
            },
            {
              "text" : " parsing strategy uses whatever input follows the key as its value, even if that input is dash-prefixed. If ",
              "type" : "text"
            },
            {
              "code" : "file",
              "type" : "codeVoice"
            },
            {
              "text" : " were defined as ",
              "type" : "text"
            },
            {
              "code" : "@Option(parsing: .unconditionalSingleValue) var file: [String]",
              "type" : "codeVoice"
            },
            {
              "text" : ", then the resulting array could include strings that look like options:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --file file1.swift --file --verbose",
            "Verbose: false, files: [\"file1.swift\", \"--verbose\"]"
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : ".upToNextOption",
              "type" : "codeVoice"
            },
            {
              "text" : " parsing strategy uses the inputs that follow the option key until reaching a dash-prefixed input. If ",
              "type" : "text"
            },
            {
              "code" : "file",
              "type" : "codeVoice"
            },
            {
              "text" : " were defined as ",
              "type" : "text"
            },
            {
              "code" : "@Option(parsing: .upToNextOption) var file: [String]",
              "type" : "codeVoice"
            },
            {
              "text" : ", then the user could specify multiple files without repeating ",
              "type" : "text"
            },
            {
              "code" : "--file",
              "type" : "codeVoice"
            },
            {
              "text" : ":",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --file file1.swift file2.swift",
            "Verbose: false, files: [\"file1.swift\", \"file2.swift\"]",
            "% example --file file1.swift file2.swift --verbose",
            "Verbose: true, files: [\"file1.swift\", \"file2.swift\"]"
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Finally, the ",
              "type" : "text"
            },
            {
              "code" : ".remaining",
              "type" : "codeVoice"
            },
            {
              "text" : " parsing strategy uses all the inputs that follow the option key, regardless of their prefix. If ",
              "type" : "text"
            },
            {
              "code" : "file",
              "type" : "codeVoice"
            },
            {
              "text" : " were defined as ",
              "type" : "text"
            },
            {
              "code" : "@Option(parsing: .remaining) var file: [String]",
              "type" : "codeVoice"
            },
            {
              "text" : ", then the user would need to specify ",
              "type" : "text"
            },
            {
              "code" : "--verbose",
              "type" : "codeVoice"
            },
            {
              "text" : " before the ",
              "type" : "text"
            },
            {
              "code" : "--file",
              "type" : "codeVoice"
            },
            {
              "text" : " key for it to be recognized as a flag:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --verbose --file file1.swift file2.swift",
            "Verbose: true, files: [\"file1.swift\", \"file2.swift\"]",
            "% example --file file1.swift file2.swift --verbose",
            "Verbose: false, files: [\"file1.swift\", \"file2.swift\", \"--verbose\"]"
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "anchor" : "Alternative-positional-argument-parsing-strategies",
          "level" : 3,
          "text" : "Alternative positional argument parsing strategies",
          "type" : "heading"
        },
        {
          "inlineContent" : [
            {
              "text" : "The default strategy for parsing arrays of positional arguments is to ignore  all dash-prefixed command-line inputs. For example, this command accepts a ",
              "type" : "text"
            },
            {
              "code" : "--verbose",
              "type" : "codeVoice"
            },
            {
              "text" : " flag and a list of file names as positional arguments:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "struct Example: ParsableCommand {",
            "    @Flag var verbose = false",
            "    @Argument var files: [String] = []",
            "",
            "    mutating func run() throws {",
            "        print(\"Verbose: \\(verbose), files: \\(files)\")",
            "    }",
            "}"
          ],
          "syntax" : "swift",
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : "files",
              "type" : "codeVoice"
            },
            {
              "text" : " argument array uses the default ",
              "type" : "text"
            },
            {
              "code" : ".remaining",
              "type" : "codeVoice"
            },
            {
              "text" : " parsing strategy, so it only picks up values that don’t have a prefix:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --verbose file1.swift file2.swift",
            "Verbose: true, files: [\"file1.swift\", \"file2.swift\"]",
            "% example --verbose file1.swift file2.swift --other",
            "Error: Unexpected argument '--other'",
            "Usage: example [--verbose] [<files> ...]",
            "  See 'example --help' for more information."
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "Any input after the ",
              "type" : "text"
            },
            {
              "code" : "--",
              "type" : "codeVoice"
            },
            {
              "text" : " terminator is automatically treated as positional input, so users can provide dash-prefixed values that way even with the default configuration:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --verbose -- file1.swift file2.swift --other",
            "Verbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]"
          ],
          "syntax" : null,
          "type" : "codeListing"
        },
        {
          "inlineContent" : [
            {
              "text" : "The ",
              "type" : "text"
            },
            {
              "code" : ".unconditionalRemaining",
              "type" : "codeVoice"
            },
            {
              "text" : " parsing strategy uses whatever input is left after parsing known options and flags, even if that input is dash-prefixed, including the terminator itself. If ",
              "type" : "text"
            },
            {
              "code" : "files",
              "type" : "codeVoice"
            },
            {
              "text" : " were defined as ",
              "type" : "text"
            },
            {
              "code" : "@Argument(parsing: .unconditionalRemaining) var files: [String]",
              "type" : "codeVoice"
            },
            {
              "text" : ", then the resulting array would also include strings that look like options:",
              "type" : "text"
            }
          ],
          "type" : "paragraph"
        },
        {
          "code" : [
            "% example --verbose file1.swift file2.swift --other",
            "Verbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]",
            "% example -- --verbose file1.swift file2.swift --other",
            "Verbose: false, files: [\"--\", \"--verbose\", \"file1.swift\", \"file2.swift\", \"--other\"]"
          ],
          "syntax" : null,
          "type" : "codeListing"
        }
      ],
      "kind" : "content"
    }
  ],
  "schemaVersion" : {
    "major" : 0,
    "minor" : 2,
    "patch" : 0
  },
  "sections" : [

  ],
  "seeAlsoSections" : [
    {
      "generated" : true,
      "identifiers" : [
        "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Argument",
        "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Option",
        "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Flag",
        "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup",
        "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments"
      ],
      "title" : "Arguments, Options, and Flags"
    }
  ],
  "variants" : [
    {
      "paths" : [
        "\/documentation\/argumentparser\/declaringarguments"
      ],
      "traits" : [
        {
          "interfaceLanguage" : "swift"
        }
      ]
    }
  ]
, 
"references": {
"doc://ArgumentParser/documentation/ArgumentParser": {
  "abstract" : [
    {
      "text" : "Straightforward, type-safe argument parsing for Swift.",
      "type" : "text"
    }
  ],
  "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser",
  "kind" : "symbol",
  "role" : "collection",
  "title" : "ArgumentParser",
  "type" : "topic",
  "url" : "\/documentation\/argumentparser"
},
"doc://ArgumentParser/documentation/ArgumentParser/Argument": {
  "abstract" : [
    {
      "text" : "A property wrapper that represents a positional command-line argument.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "struct"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "Argument"
    }
  ],
  "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Argument",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "Argument"
    }
  ],
  "role" : "symbol",
  "title" : "Argument",
  "type" : "topic",
  "url" : "\/documentation\/argumentparser\/argument"
},
"doc://ArgumentParser/documentation/ArgumentParser/EnumerableFlag": {
  "abstract" : [
    {
      "text" : "A type that represents the different possible flags to be used by a",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "code" : "@Flag",
      "type" : "codeVoice"
    },
    {
      "text" : " property.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "protocol"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "EnumerableFlag"
    }
  ],
  "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/EnumerableFlag",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "EnumerableFlag"
    }
  ],
  "role" : "symbol",
  "title" : "EnumerableFlag",
  "type" : "topic",
  "url" : "\/documentation\/argumentparser\/enumerableflag"
},
"doc://ArgumentParser/documentation/ArgumentParser/ExpressibleByArgument": {
  "abstract" : [
    {
      "text" : "A type that can be expressed as a command-line argument.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "protocol"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "ExpressibleByArgument"
    }
  ],
  "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "ExpressibleByArgument"
    }
  ],
  "role" : "symbol",
  "title" : "ExpressibleByArgument",
  "type" : "topic",
  "url" : "\/documentation\/argumentparser\/expressiblebyargument"
},
"doc://ArgumentParser/documentation/ArgumentParser/ExpressibleByArgument/init(argument:)": {
  "abstract" : [
    {
      "text" : "Creates a new instance of this type from a command-line-specified",
      "type" : "text"
    },
    {
      "text" : " ",
      "type" : "text"
    },
    {
      "text" : "argument.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "identifier",
      "text" : "init"
    },
    {
      "kind" : "text",
      "text" : "?("
    },
    {
      "kind" : "externalParam",
      "text" : "argument"
    },
    {
      "kind" : "text",
      "text" : ": "
    },
    {
      "kind" : "typeIdentifier",
      "preciseIdentifier" : "s:SS",
      "text" : "String"
    },
    {
      "kind" : "text",
      "text" : ")"
    }
  ],
  "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ExpressibleByArgument\/init(argument:)",
  "kind" : "symbol",
  "required" : true,
  "role" : "symbol",
  "title" : "init(argument:)",
  "type" : "topic",
  "url" : "\/documentation\/argumentparser\/expressiblebyargument\/init(argument:)"
},
"doc://ArgumentParser/documentation/ArgumentParser/Flag": {
  "abstract" : [
    {
      "text" : "A property wrapper that represents a command-line flag.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "struct"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "Flag"
    }
  ],
  "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Flag",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "Flag"
    }
  ],
  "role" : "symbol",
  "title" : "Flag",
  "type" : "topic",
  "url" : "\/documentation\/argumentparser\/flag"
},
"doc://ArgumentParser/documentation/ArgumentParser/Option": {
  "abstract" : [
    {
      "text" : "A property wrapper that represents a command-line option.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "struct"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "Option"
    }
  ],
  "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Option",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "Option"
    }
  ],
  "role" : "symbol",
  "title" : "Option",
  "type" : "topic",
  "url" : "\/documentation\/argumentparser\/option"
},
"doc://ArgumentParser/documentation/ArgumentParser/OptionGroup": {
  "abstract" : [
    {
      "text" : "A wrapper that transparently includes a parsable type.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "struct"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "OptionGroup"
    }
  ],
  "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "OptionGroup"
    }
  ],
  "role" : "symbol",
  "title" : "OptionGroup",
  "type" : "topic",
  "url" : "\/documentation\/argumentparser\/optiongroup"
},
"doc://ArgumentParser/documentation/ArgumentParser/ParsableArguments": {
  "abstract" : [
    {
      "text" : "A type that can be parsed from a program’s command-line arguments.",
      "type" : "text"
    }
  ],
  "fragments" : [
    {
      "kind" : "keyword",
      "text" : "protocol"
    },
    {
      "kind" : "text",
      "text" : " "
    },
    {
      "kind" : "identifier",
      "text" : "ParsableArguments"
    }
  ],
  "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments",
  "kind" : "symbol",
  "navigatorTitle" : [
    {
      "kind" : "identifier",
      "text" : "ParsableArguments"
    }
  ],
  "role" : "symbol",
  "title" : "ParsableArguments",
  "type" : "topic",
  "url" : "\/documentation\/argumentparser\/parsablearguments"
},
"doc://ArgumentParser/documentation/ArgumentParser/Validation": {
  "abstract" : [
    {
      "text" : "Provide helpful feedback to users when things go wrong.",
      "type" : "text"
    }
  ],
  "identifier" : "doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Validation",
  "kind" : "article",
  "role" : "article",
  "title" : "Providing Custom Validation",
  "type" : "topic",
  "url" : "\/documentation\/argumentparser\/validation"
}
}
}